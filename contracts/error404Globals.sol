// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

/*
                            ___ _____    ___ 
                           /   |  _  |  /   |
  ___ _ __ _ __ ___  _ __ / /| | |/' | / /| |
 / _ \ '__| '__/ _ \| '__/ /_| |  /| |/ /_| |
|  __/ |  | | | (_) | |  \___  \ |_/ /\___  |
 \___|_|  |_|  \___/|_|      |_/\___/     |_/
                                             
 Website: https://error404.finance
 twitter: https://twitter.com/Error404Finance
*/

import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import '@openzeppelin/contracts/token/ERC721/IERC721.sol';
import "@openzeppelin/contracts/access/Ownable.sol";
import "./libs/IHelper.sol";

contract error404Globals is Ownable {
    using SafeMath for uint256;

    // error404 token address
    address public token;
    // address of the nfts
    address public nft;
    // Address of the lottery contract
    address public lottery;
    // Address of the minters contract
    address public minter;
    // Address of the referrals contract
    address public referrals;
    // Developer address where the tokens generated by the chefs fall
    address public devaddr;
    // Fee address for repurchase where the fees deposited by users fall
    address public feeAddress;
    // Address the contract of the profit strategy and add liquidity
    address public reward;
    // Percentage of tokens created for the lottery
    uint256 public rewardLottery;
    // Percentage of tokens created for sponsors
    uint256 public rewardSponsors;
    // Percentage of tokens created for developer
    uint256 public rewardDevs;
    // Percentage of fees for developer
    uint256 public feeDevs;
    // List of the path for the exchange of tokens
    mapping(address => mapping(uint256 => address[])) public paths;

    constructor(
        address _token,
        address _nft,
        address _lottery,
        address _minter,
        address _referrals,
        address _devaddr,
        address _feeAddress,
        address _reward
    ) public {
        token = _token;
        nft = _nft;
        lottery = _lottery;
        minter = _minter;
        referrals = _referrals;
        devaddr = _devaddr;
        feeAddress = _feeAddress;
        reward = _reward;
    }

    // Update dev address.
    function dev(address _addr) external onlyOwner {
        devaddr = _addr;
        emit eventSetDevAddress(msg.sender, _addr);
    }

    // Update fee address.
    function setFeeAddress(address _addr) external onlyOwner{
        feeAddress = _addr;
        emit eventSetFeeAddress(msg.sender, _addr);
    }

    // Update referrals address.
    function setReferralsAddress(address _addr) external onlyOwner{
        referrals = _addr;
        emit eventSetReferralsAddress(msg.sender, _addr);
    }

    // Update minter address.
    function setMinterAddress(address _addr) external onlyOwner{
        minter = _addr;
        emit eventSetMinterAddress(msg.sender, _addr);
    }

    // Update lottery address.
    function setLotteryAddress(address _addr) external onlyOwner{
        lottery = _addr;
        emit eventSetLotteryAddress(msg.sender, _addr);
    }

    // Update nft address.
    function setNFTAddress(address _addr) external onlyOwner{
        nft = _addr;
        emit eventSetNFTAddress(msg.sender, _addr);
    }

    // Update token address.
    function setTokenAddress(address _addr) external onlyOwner{
        token = _addr;
        emit eventSetTokenAddress(msg.sender, _addr);
    }

    // Update reward address.
    function setRewardAddress(address _addr) external onlyOwner{
        reward = _addr;
        emit eventSetRewardAddress(msg.sender, _addr);
    }

    // Update reward lottery.
    function setRewardLottery(uint256 _value) external onlyOwner{
        rewardLottery = _value;
        emit eventSetRewardLottery(msg.sender, _value);
    }

    // Update reward sponsors.
    function setRewardSponsors(uint256 _value) external onlyOwner{
        rewardSponsors = _value;
        emit eventSetRewardSponsors(msg.sender, _value);
    }

    // Update reward devs.
    function setRewardDevs(uint256 _value) external onlyOwner{
        rewardDevs = _value;
        emit eventSetRewardDevs(msg.sender, _value);
    }

    // Update fees devs.
    function setFeeDevs(uint256 _value) external onlyOwner{
        feeDevs = _value;
        emit eventSetFeedDevs(msg.sender, _value);
    }    

    // function to update the path of a token
    function setPath(address _token, uint256 _id, address[] calldata _path) external onlyOwner{
        paths[_token][_id] = _path;
        emit eventSetpath(_token, _id);
    }

    // function that returns the path of the token routes
    function getPaths(address _token, uint256 _id) public view returns(address[] memory) {
        uint256 _length =  paths[_token][_id].length;
        address[] memory _paths = new address[](_length);
        for (uint256 i = 0; i < _length; i++) {
            _paths[i] = paths[_token][_id][i];
        }
        return _paths;
    }    

    event eventSetDevAddress(address indexed user, address indexed _addr);
    event eventSetFeeAddress(address indexed user, address indexed _addr);
    event eventSetReferralsAddress(address indexed user, address indexed _addr);
    event eventSetMinterAddress(address indexed user, address indexed _addr);
    event eventSetLotteryAddress(address indexed user, address indexed _addr);
    event eventSetNFTAddress(address indexed user, address indexed _addr);
    event eventSetTokenAddress(address indexed user, address indexed _addr);
    event eventSetRewardAddress(address indexed user, address indexed _addr);
    event eventSetRewardLottery(address indexed user, uint256 _value);
    event eventSetRewardSponsors(address indexed user, uint256 _value);
    event eventSetRewardDevs(address indexed user, uint256 _value);
    event eventSetFeedDevs(address indexed user, uint256 _value);
    event eventSetpath(address indexed user, uint256 _id);

}