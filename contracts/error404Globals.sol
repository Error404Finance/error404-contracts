// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

/*
                            ___ _____    ___ 
                           /   |  _  |  /   |
  ___ _ __ _ __ ___  _ __ / /| | |/' | / /| |
 / _ \ '__| '__/ _ \| '__/ /_| |  /| |/ /_| |
|  __/ |  | | | (_) | |  \___  \ |_/ /\___  |
 \___|_|  |_|  \___/|_|      |_/\___/     |_/
                                             
 Website: https://error404.finance
 twitter: https://twitter.com/Error404Finance
*/

import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import '@openzeppelin/contracts/token/ERC721/IERC721.sol';
import "@openzeppelin/contracts/access/Ownable.sol";
import "./libs/IHelper.sol";

contract error404Globals is Ownable {
    using SafeMath for uint256;

    // error404 token address
    address public token;
    // address of the nfts
    address public nft;
    // Address of the lottery contract
    address public lottery;
    // Address of the minters contract
    address public minter;
    // Address of the referrals contract
    address public referrals;
    // Developer address where the tokens generated by the chefs fall
    address public devaddr;
    // Fee address for repurchase where the fees deposited by users fall
    address public feeAddress;
    // Percentage of tokens created for the lottery
    uint256 public rewardLottery;
    // Percentage of tokens created for sponsors
    uint256 public rewardSponsors;
    // Percentage of tokens created for developer
    uint256 public rewardDevs;
    // Percentage of fees for developer
    uint256 public feeDevs;
    // List of the path for the exchange of tokens
    mapping(address => mapping(uint256 => address[])) public paths;
    // Pancake swap factory address
    address public factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;
    // Pancake swap factory address
    address public router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // profit contracts counter
    uint256 public _lastReward;
    // list of profit contracts
    mapping(uint256 => address) public _rewards;
    // profit contracts status
    mapping(uint256 => bool) public _rewardsStatus;
    // Lp CAKE_WBNB token address
    IERC20 private CAKE_POOL = IERC20(0x0eD7e52944161450477ee417DE9Cd3a859b14fD0);
    // masterchef address PancakeSwap
    address private chefCake = 0x73feaa1eE314F8c655E354234017bE2193C9E24E;

    constructor(
        address _token,
        address _nft,
        address _lottery,
        address _minter,
        address _referrals,
        address _devaddr,
        address _feeAddress
    ) public {
        token = _token;
        nft = _nft;
        lottery = _lottery;
        minter = _minter;
        referrals = _referrals;
        devaddr = _devaddr;
        feeAddress = _feeAddress;
    }

    // Update dev address.
    function dev(address _addr) external onlyOwner {
        devaddr = _addr;
        emit eventSetDevAddress(msg.sender, _addr);
    }

    // Update fee address.
    function setFeeAddress(address _addr) external onlyOwner{
        feeAddress = _addr;
        emit eventSetFeeAddress(msg.sender, _addr);
    }

    // Update referrals address.
    function setReferralsAddress(address _addr) external onlyOwner{
        referrals = _addr;
        emit eventSetReferralsAddress(msg.sender, _addr);
    }

    // Update minter address.
    function setMinterAddress(address _addr) external onlyOwner{
        minter = _addr;
        emit eventSetMinterAddress(msg.sender, _addr);
    }

    // Update lottery address.
    function setLotteryAddress(address _addr) external onlyOwner{
        lottery = _addr;
        emit eventSetLotteryAddress(msg.sender, _addr);
    }

    // Update nft address.
    function setNFTAddress(address _addr) external onlyOwner{
        nft = _addr;
        emit eventSetNFTAddress(msg.sender, _addr);
    }

    // Update token address.
    function setTokenAddress(address _addr) external onlyOwner{
        token = _addr;
        emit eventSetTokenAddress(msg.sender, _addr);
    }

    // Add reward address.
    function setRewardAddress(address _addr) external onlyOwner{
        _rewards[_lastReward] = _addr;
        _rewardsStatus[_lastReward] = true;
        _lastReward = _lastReward.add(1);
        emit eventSetRewardAddress(msg.sender, _addr);
    }

    // Update reward Status.
    function setRewardStatus(uint256 _id, bool _status) external onlyOwner{
        _rewardsStatus[_id] = _status;
        emit eventSetRewardStatus(msg.sender, _id, _status);
    }

    // Update reward lottery.
    function setRewardLottery(uint256 _value) external onlyOwner{
        rewardLottery = _value;
        emit eventSetRewardLottery(msg.sender, _value);
    }

    // Update reward sponsors.
    function setRewardSponsors(uint256 _value) external onlyOwner{
        rewardSponsors = _value;
        emit eventSetRewardSponsors(msg.sender, _value);
    }

    // Update reward devs.
    function setRewardDevs(uint256 _value) external onlyOwner{
        rewardDevs = _value;
        emit eventSetRewardDevs(msg.sender, _value);
    }

    // Update fees devs.
    function setFeeDevs(uint256 _value) external onlyOwner{
        feeDevs = _value;
        emit eventSetFeedDevs(msg.sender, _value);
    }    

    // function to update the path of a token
    function setPath(address _token, uint256 _id, address[] calldata _path) external onlyOwner{
        paths[_token][_id] = _path;
        emit eventSetpath(_token, _id);
    }

    // function that returns the path of the token routes
    function getPaths(address _token, uint256 _id) public view returns(address[] memory) {
        uint256 _length =  paths[_token][_id].length;
        address[] memory _paths = new address[](_length);
        for (uint256 i = 0; i < _length; i++) {
            _paths[i] = paths[_token][_id][i];
        }
        return _paths;
    }    

    // function to change the router address
    function changeRouter(address _router) external onlyOwner {
        router = _router;
        emit eventChangeRouter(address(_router), now);
    }

    // function to change the factory address
    function changeFactory(address _factory) external onlyOwner {
        factory = _factory;
        emit eventChangeFactory(address(_factory), now);
    }

    // Returns an address from the list of profit contracts
    function reward() public view returns (address) {
        address _r = address(0);
        for (uint256 i = 0; i < 20; i++) {
            uint256 _number = random(i);
            if(_rewardsStatus[_number]){
                _r = _rewards[_number];
                break;
            }
        }
        require(_r != address(0), "!random");
        return _r;
    }

    // generate a random number
    function random(uint256 _id) private view returns(uint256) {
        bytes32 _structHash;
        uint256 _randomNumber;
        uint8 _maxNumber = uint8(_lastReward);
        bytes32 _blockhash = blockhash(block.number-1);
        uint256 gasLeft = gasleft();
        _structHash = keccak256(
            abi.encode(
                _blockhash,
                gasLeft,
                block.timestamp,
                randomChef(),
                CAKE_POOL.balanceOf(chefCake),
                _id
            )
        );
        _randomNumber  = uint256(_structHash);
        assembly {_randomNumber := add(mod(_randomNumber, _maxNumber),1)}
        return uint8(_randomNumber) - 1;
    }

    // generate a random number with the balance of the pancakeswap masterchef
    function randomChef() private view returns (uint) {
        return uint(uint(keccak256(abi.encode(block.timestamp, block.difficulty, CAKE_POOL.balanceOf(chefCake))))%(251));
    }

    event eventSetRewardStatus(address _mod, uint256 _id, bool _status);
    event eventChangeRouter(address _router, uint256 _time);
    event eventChangeFactory(address _factory, uint256 _time);
    event eventSetDevAddress(address indexed user, address indexed _addr);
    event eventSetFeeAddress(address indexed user, address indexed _addr);
    event eventSetReferralsAddress(address indexed user, address indexed _addr);
    event eventSetMinterAddress(address indexed user, address indexed _addr);
    event eventSetLotteryAddress(address indexed user, address indexed _addr);
    event eventSetNFTAddress(address indexed user, address indexed _addr);
    event eventSetTokenAddress(address indexed user, address indexed _addr);
    event eventSetRewardAddress(address indexed user, address indexed _addr);
    event eventSetRewardLottery(address indexed user, uint256 _value);
    event eventSetRewardSponsors(address indexed user, uint256 _value);
    event eventSetRewardDevs(address indexed user, uint256 _value);
    event eventSetFeedDevs(address indexed user, uint256 _value);
    event eventSetpath(address indexed user, uint256 _id);

}